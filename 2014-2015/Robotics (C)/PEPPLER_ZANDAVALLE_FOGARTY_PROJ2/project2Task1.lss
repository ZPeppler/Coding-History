
project2Task1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d6  00800100  00000d42  00000dd6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  008001d6  008001d6  00000eac  2**0
                  ALLOC
  3 .stab         00001d94  00000000  00000000  00000eac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000cb2  00000000  00000000  00002c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  000038f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000028a  00000000  00000000  00003932  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000079f  00000000  00000000  00003bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000029b  00000000  00000000  0000435b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000008bd  00000000  00000000  000045f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000260  00000000  00000000  00004eb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002dd  00000000  00000000  00005114  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000367  00000000  00000000  000053f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000004a  00000000  00000000  00005758  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000018  00000000  00000000  000057a2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d4 e0       	ldi	r29, 0x04	; 4
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e4       	ldi	r30, 0x42	; 66
  7c:	fd e0       	ldi	r31, 0x0D	; 13
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a6 3d       	cpi	r26, 0xD6	; 214
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a6 ed       	ldi	r26, 0xD6	; 214
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a9 3d       	cpi	r26, 0xD9	; 217
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 8e 02 	call	0x51c	; 0x51c <main>
  9e:	0c 94 9f 06 	jmp	0xd3e	; 0xd3e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <setupRightLED>:
   for port D to one. This sets pin 5 of Port D, which
   controls the right LED, to output mode. Done once before
   calling rightLEDOn() */
void setupRightLED(void)
{
   DDRD != (1 << 5);
  a6:	8a b1       	in	r24, 0x0a	; 10
}
  a8:	08 95       	ret

000000aa <rightLEDOn>:
/* Since these LEDs use an active low system, we write a 0 to
   turn the LEDs on. This sets of the fifth bit of port D to
   0, which will turn on the right LED on. */
void rightLEDOn(void)
{
   PORTD &= ~(1 << 5);
  aa:	5d 98       	cbi	0x0b, 5	; 11
}
  ac:	08 95       	ret

000000ae <rightLEDOff>:
/* Since these LEDs use an active low system, we write a 1 to
   turn the LEDs on. This sets of the fifth bit of port D to
   1, which will turn on the right LED off. */
void rightLEDOff(void)
{
   PORTD |= 0x20;
  ae:	5d 9a       	sbi	0x0b, 5	; 11
}
  b0:	08 95       	ret

000000b2 <setupLeftLED>:
   for port D to one. This sets pin 6 of Port D, which
   controls the left LED, to output mode. Done once before
   calling leftLEDOn() */
void setupLeftLED(void)
{
   DDRD != (1 << 6);
  b2:	8a b1       	in	r24, 0x0a	; 10
}
  b4:	08 95       	ret

000000b6 <leftLEDOn>:
/* Since these LEDs use an active low system, we write a 0 to
   turn the LEDs on. This sets of the sixth bit of port D to
   0, which will turn on the left LED on. */
void leftLEDOn(void)
{
   PORTD &= ~(1 << 6);
  b6:	5e 98       	cbi	0x0b, 6	; 11
}
  b8:	08 95       	ret

000000ba <leftLEDOff>:
/* Since these LEDs use an active low system, we write a 1 to
   turn the LEDs on. This sets of the sixth bit of port D to
   1, which will turn on the right LED off. */
void leftLEDOff(void)
{
   PORTD |= 0x40;
  ba:	5e 9a       	sbi	0x0b, 6	; 11
}
  bc:	08 95       	ret

000000be <setupTimer>:
   special codes for which details appear in the ATMega168 data
   sheet. The 71 is a computed value based on processor speed and 
   the amount of "scaling of the timer" that gives us 1ms intervals. */
void setupTimer(void)
{
   TCCR1A = 0x00;
  be:	10 92 80 00 	sts	0x0080, r1
   TCCR1B = 0x0C;
  c2:	8c e0       	ldi	r24, 0x0C	; 12
  c4:	80 93 81 00 	sts	0x0081, r24
   OCR1A = 71;
  c8:	87 e4       	ldi	r24, 0x47	; 71
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	90 93 89 00 	sts	0x0089, r25
  d0:	80 93 88 00 	sts	0x0088, r24
   TIMSK1 = 0x02;
  d4:	82 e0       	ldi	r24, 0x02	; 2
  d6:	80 93 6f 00 	sts	0x006F, r24
}
  da:	08 95       	ret

000000dc <delayMs>:

/* Delay for a number of milliseconds. Call setupTimer() before this. */
void delayMs(uint16_t timeMs)
{
   timerCount = timeMs;
  dc:	90 93 d7 01 	sts	0x01D7, r25
  e0:	80 93 d6 01 	sts	0x01D6, r24
   timerRunning = 1;
  e4:	81 e0       	ldi	r24, 0x01	; 1
  e6:	80 93 d8 01 	sts	0x01D8, r24
   while(timerRunning != 0)
  ea:	80 91 d8 01 	lds	r24, 0x01D8
  ee:	88 23       	and	r24, r24
  f0:	e1 f7       	brne	.-8      	; 0xea <delayMs+0xe>
   {
    //do nothing
   }
}
  f2:	08 95       	ret

000000f4 <__vector_11>:

/* Interrupt handler called every 1ms. We decrement the counter variable
   to allow delayMs to keep time */
SIGNAL(TIMER1_COMPA_vect)
{
  f4:	1f 92       	push	r1
  f6:	0f 92       	push	r0
  f8:	0f b6       	in	r0, 0x3f	; 63
  fa:	0f 92       	push	r0
  fc:	11 24       	eor	r1, r1
  fe:	8f 93       	push	r24
 100:	9f 93       	push	r25
   if(timerRunning != 0)
 102:	80 91 d8 01 	lds	r24, 0x01D8
 106:	88 23       	and	r24, r24
 108:	91 f0       	breq	.+36     	; 0x12e <__vector_11+0x3a>
   {
      if(timerCount != 0)
 10a:	80 91 d6 01 	lds	r24, 0x01D6
 10e:	90 91 d7 01 	lds	r25, 0x01D7
 112:	00 97       	sbiw	r24, 0x00	; 0
 114:	51 f0       	breq	.+20     	; 0x12a <__vector_11+0x36>
      {
         timerCount--;
 116:	80 91 d6 01 	lds	r24, 0x01D6
 11a:	90 91 d7 01 	lds	r25, 0x01D7
 11e:	01 97       	sbiw	r24, 0x01	; 1
 120:	90 93 d7 01 	sts	0x01D7, r25
 124:	80 93 d6 01 	sts	0x01D6, r24
 128:	02 c0       	rjmp	.+4      	; 0x12e <__vector_11+0x3a>
      }
      else
      {
         timerRunning = 0;
 12a:	10 92 d8 01 	sts	0x01D8, r1
      }
   }

   if(responseTimer != 0)
 12e:	80 91 00 01 	lds	r24, 0x0100
 132:	90 91 01 01 	lds	r25, 0x0101
 136:	00 97       	sbiw	r24, 0x00	; 0
 138:	49 f0       	breq	.+18     	; 0x14c <__vector_11+0x58>
   {
      responseTimer--;
 13a:	80 91 00 01 	lds	r24, 0x0100
 13e:	90 91 01 01 	lds	r25, 0x0101
 142:	01 97       	sbiw	r24, 0x01	; 1
 144:	90 93 01 01 	sts	0x0101, r25
 148:	80 93 00 01 	sts	0x0100, r24
   }
}
 14c:	9f 91       	pop	r25
 14e:	8f 91       	pop	r24
 150:	0f 90       	pop	r0
 152:	0f be       	out	0x3f, r0	; 63
 154:	0f 90       	pop	r0
 156:	1f 90       	pop	r1
 158:	18 95       	reti

0000015a <setupSerialPort>:

/* Set the transmission speed to 57600 baud, which is what the Create
   expects unless we tell it otherwise.*/
void setupSerialPort(void)
{
   UBRR0 = 19;
 15a:	83 e1       	ldi	r24, 0x13	; 19
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	90 93 c5 00 	sts	0x00C5, r25
 162:	80 93 c4 00 	sts	0x00C4, r24
   UCSR0B = 0x18;
 166:	88 e1       	ldi	r24, 0x18	; 24
 168:	80 93 c1 00 	sts	0x00C1, r24
   UCSR0C = 0x06;
 16c:	86 e0       	ldi	r24, 0x06	; 6
 16e:	80 93 c2 00 	sts	0x00C2, r24
}
 172:	08 95       	ret

00000174 <byteTx>:
   the time it takes the UART to obtain each byte. After that we
   transmit one byte to the robot, wait for the buffer to be 
   empty, and then send the byte. */
void byteTx(uint8_t value)
{
   while(!(UCSR0A & 0x20))
 174:	90 91 c0 00 	lds	r25, 0x00C0
 178:	95 ff       	sbrs	r25, 5
 17a:	fc cf       	rjmp	.-8      	; 0x174 <byteTx>
   { 
    //do nothing
   }

   UDR0 = value;
 17c:	80 93 c6 00 	sts	0x00C6, r24
}
 180:	08 95       	ret

00000182 <byteRx>:
   Calling setupSerialPort() should be done first. It will wait
   for a byte to arrive in the receive buffer before returning
   that byte. */
uint8_t byteRx(void)
{
   while(!(UCSR0A & 0x80));
 182:	80 91 c0 00 	lds	r24, 0x00C0
 186:	87 ff       	sbrs	r24, 7
 188:	fc cf       	rjmp	.-8      	; 0x182 <byteRx>

   return UDR0;
 18a:	80 91 c6 00 	lds	r24, 0x00C6
}
 18e:	08 95       	ret

00000190 <byteRx16>:

uint16_t byteRx16(void)
{
 190:	1f 93       	push	r17
   uint8_t high, low;
   high = byteRx();
 192:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
 196:	18 2f       	mov	r17, r24
   low = byteRx();
 198:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
   return ((high << 8)|low);
 19c:	51 2f       	mov	r21, r17
 19e:	40 e0       	ldi	r20, 0x00	; 0
 1a0:	28 2f       	mov	r18, r24
 1a2:	30 e0       	ldi	r19, 0x00	; 0
 1a4:	24 2b       	or	r18, r20
 1a6:	35 2b       	or	r19, r21
}
 1a8:	c9 01       	movw	r24, r18
 1aa:	1f 91       	pop	r17
 1ac:	08 95       	ret

000001ae <driveStraight>:
   robot forward at any velocity (mm/s) that's between 0 and 255, 
   since it only takes in an eight bit unsigned integer. 
   A special code is used for the radius in order to make it
   drive straight, which was provided in the Open Interface. */
void driveStraight(uint8_t velocity)
{
 1ae:	1f 93       	push	r17
 1b0:	18 2f       	mov	r17, r24
   byteTx(OC_DRIVE);
 1b2:	89 e8       	ldi	r24, 0x89	; 137
 1b4:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(0);
 1b8:	80 e0       	ldi	r24, 0x00	; 0
 1ba:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(velocity);
 1be:	81 2f       	mov	r24, r17
 1c0:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STRAIGHT1);
 1c4:	80 e8       	ldi	r24, 0x80	; 128
 1c6:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STRAIGHT2);
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 1d0:	1f 91       	pop	r17
 1d2:	08 95       	ret

000001d4 <stop>:
   done using driveStraight(0), having a speific function
   telling it to stop is more useful and makes the code 
   easier to read. */
void stop(void)
{
   byteTx(OC_DRIVE);
 1d4:	89 e8       	ldi	r24, 0x89	; 137
 1d6:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STOP_VELOCITY);
 1da:	80 e0       	ldi	r24, 0x00	; 0
 1dc:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STOP_VELOCITY);
 1e0:	80 e0       	ldi	r24, 0x00	; 0
 1e2:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STOP_RADIUS);
 1e6:	80 e0       	ldi	r24, 0x00	; 0
 1e8:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_STOP_RADIUS);
 1ec:	80 e0       	ldi	r24, 0x00	; 0
 1ee:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 1f2:	08 95       	ret

000001f4 <turnClockwise>:
   robot in place going clockwise. Again, like driveStraight
   this is limited to a velocity between 0 and 255. A special
   code was used to make this robot turn in place, provided
   by the Open Interface. */
void turnClockwise(uint8_t velocity)
{
 1f4:	1f 93       	push	r17
 1f6:	18 2f       	mov	r17, r24
   byteTx(OC_DRIVE);
 1f8:	89 e8       	ldi	r24, 0x89	; 137
 1fa:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(0);
 1fe:	80 e0       	ldi	r24, 0x00	; 0
 200:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(velocity);
 204:	81 2f       	mov	r24, r17
 206:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_CW1);
 20a:	8f ef       	ldi	r24, 0xFF	; 255
 20c:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_CW2);
 210:	8f ef       	ldi	r24, 0xFF	; 255
 212:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 216:	1f 91       	pop	r17
 218:	08 95       	ret

0000021a <turnCounterClockwise>:
   robot in place going counterclockwise. Again, like driveStraight
   this is limited to a velocity between 0 and 255. A special
   code was used to make this robot turn in place, provided
   by the Open Interface. */
void turnCounterClockwise(uint8_t velocity)
{
 21a:	1f 93       	push	r17
 21c:	18 2f       	mov	r17, r24
   byteTx(OC_DRIVE);
 21e:	89 e8       	ldi	r24, 0x89	; 137
 220:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(0);
 224:	80 e0       	ldi	r24, 0x00	; 0
 226:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(velocity);
 22a:	81 2f       	mov	r24, r17
 22c:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_CCW1);
 230:	80 e0       	ldi	r24, 0x00	; 0
 232:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(DRIVE_CCW2);
 236:	81 e0       	ldi	r24, 0x01	; 1
 238:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 23c:	1f 91       	pop	r17
 23e:	08 95       	ret

00000240 <waitTime>:

/* Using an Op Code for waiting, this function will wait a 
   certain amount of time. */
void waitTime(uint8_t time)
{
 240:	1f 93       	push	r17
 242:	18 2f       	mov	r17, r24
   byteTx(OC_WAIT_TIME);
 244:	8b e9       	ldi	r24, 0x9B	; 155
 246:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(time);
 24a:	81 2f       	mov	r24, r17
 24c:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
//   return 0;
}
 250:	1f 91       	pop	r17
 252:	08 95       	ret

00000254 <waitEvent>:

/* Using an Op code for waiting, this function will wait
   until a predetermined event occurs. */
void waitEvent(uint8_t event)
{
 254:	1f 93       	push	r17
 256:	18 2f       	mov	r17, r24
   byteTx(OC_WAIT_EVENT);
 258:	8e e9       	ldi	r24, 0x9E	; 158
 25a:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(event);
 25e:	81 2f       	mov	r24, r17
 260:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 264:	1f 91       	pop	r17
 266:	08 95       	ret

00000268 <driveStraightTime>:

/* Using a combination of the driveStraight() and delayMs()
   functions, this function will drive straight at a specific
   velocity for a specific time. */
void driveStraightTime(uint8_t velocity, uint16_t timeMs)
{
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	eb 01       	movw	r28, r22
   driveStraight(velocity);
 26e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <driveStraight>
   delayMs(timeMs);
 272:	ce 01       	movw	r24, r28
 274:	0e 94 6e 00 	call	0xdc	; 0xdc <delayMs>
}
 278:	df 91       	pop	r29
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret

0000027e <turnCCWTime>:

/* Using a combination of the turnCounterClockwise() and delayMs()
   functions, this function will have the robot turn in place
   counterclockwise for a specific amount of time. */
void turnCCWTime(uint8_t velocity, uint16_t timeMs)
{
 27e:	cf 93       	push	r28
 280:	df 93       	push	r29
 282:	eb 01       	movw	r28, r22
   turnCounterClockwise(velocity);
 284:	0e 94 0d 01 	call	0x21a	; 0x21a <turnCounterClockwise>
   delayMs(timeMs);
 288:	ce 01       	movw	r24, r28
 28a:	0e 94 6e 00 	call	0xdc	; 0xdc <delayMs>
}
 28e:	df 91       	pop	r29
 290:	cf 91       	pop	r28
 292:	08 95       	ret

00000294 <turnCWTime>:

/* Using a combination of the turnClockwise() and delayMs()
   functions, this function will have the robot turn in place
   clockwise for a specific amount of time. */
void turnCWTime(uint8_t velocity, uint16_t timeMs)
{
 294:	cf 93       	push	r28
 296:	df 93       	push	r29
 298:	eb 01       	movw	r28, r22
   turnClockwise(velocity);
 29a:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <turnClockwise>
   delayMs(timeMs);
 29e:	ce 01       	movw	r24, r28
 2a0:	0e 94 6e 00 	call	0xdc	; 0xdc <delayMs>
}
 2a4:	df 91       	pop	r29
 2a6:	cf 91       	pop	r28
 2a8:	08 95       	ret

000002aa <setSerialDestination>:

/* The code in the create notes to send data to and from the
   robot */
void setSerialDestination(uint8_t dest)
{
 2aa:	1f 93       	push	r17
 2ac:	18 2f       	mov	r17, r24
   delayMs(10);
 2ae:	8a e0       	ldi	r24, 0x0A	; 10
 2b0:	90 e0       	ldi	r25, 0x00	; 0
 2b2:	0e 94 6e 00 	call	0xdc	; 0xdc <delayMs>

   if(dest == SERIAL_CREATE)
 2b6:	11 30       	cpi	r17, 0x01	; 1
 2b8:	11 f4       	brne	.+4      	; 0x2be <setSerialDestination+0x14>
   {
      PORTB &= ~0x10;
 2ba:	2c 98       	cbi	0x05, 4	; 5
 2bc:	01 c0       	rjmp	.+2      	; 0x2c0 <setSerialDestination+0x16>
   }
   else
   {
      PORTB |= 0x10;
 2be:	2c 9a       	sbi	0x05, 4	; 5
   }

   delayMs(10);
 2c0:	8a e0       	ldi	r24, 0x0A	; 10
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	0e 94 6e 00 	call	0xdc	; 0xdc <delayMs>
}
 2c8:	1f 91       	pop	r17
 2ca:	08 95       	ret

000002cc <bumpTrigger>:
/* Checks to see if either bump sensor has been triggered. 
   Returns a 1 if either have been or a 0 if they haven't. */

int bumpTrigger(void)
{
  byteTx(OC_READ_SENSORS);
 2cc:	8e e8       	ldi	r24, 0x8E	; 142
 2ce:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
  byteTx(SEN_BUMPS_AND_WHEELS_DROP);
 2d2:	87 e0       	ldi	r24, 0x07	; 7
 2d4:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
  uint8_t bumpDrop = byteRx();
 2d8:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
      
  return (( bumpDrop & 1) || (bumpDrop & 2));
 2dc:	80 fd       	sbrc	r24, 0
 2de:	07 c0       	rjmp	.+14     	; 0x2ee <bumpTrigger+0x22>
 2e0:	21 e0       	ldi	r18, 0x01	; 1
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	81 fd       	sbrc	r24, 1
 2e6:	05 c0       	rjmp	.+10     	; 0x2f2 <bumpTrigger+0x26>
 2e8:	20 e0       	ldi	r18, 0x00	; 0
 2ea:	30 e0       	ldi	r19, 0x00	; 0
 2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <bumpTrigger+0x26>
 2ee:	21 e0       	ldi	r18, 0x01	; 1
 2f0:	30 e0       	ldi	r19, 0x00	; 0
}
 2f2:	c9 01       	movw	r24, r18
 2f4:	08 95       	ret

000002f6 <cliffTrigger>:

/* Checks to see if any of the cliff sensors have been
   triggered. Returns a 1 if one has or a 0 if none have. */

int cliffTrigger(void)
{
 2f6:	ff 92       	push	r15
 2f8:	0f 93       	push	r16
 2fa:	1f 93       	push	r17
   byteTx(OC_READ_SENSORS);
 2fc:	8e e8       	ldi	r24, 0x8E	; 142
 2fe:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(SEN_CLIFF_L);
 302:	89 e0       	ldi	r24, 0x09	; 9
 304:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   uint8_t cliffL = byteRx();
 308:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
 30c:	08 2f       	mov	r16, r24
   byteTx(OC_READ_SENSORS);
 30e:	8e e8       	ldi	r24, 0x8E	; 142
 310:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(SEN_CLIFF_FL);
 314:	8a e0       	ldi	r24, 0x0A	; 10
 316:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   uint8_t cliffFL = byteRx();      
 31a:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
 31e:	f8 2e       	mov	r15, r24
   byteTx(OC_READ_SENSORS);
 320:	8e e8       	ldi	r24, 0x8E	; 142
 322:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(SEN_CLIFF_FR);
 326:	8b e0       	ldi	r24, 0x0B	; 11
 328:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   uint8_t cliffFR = byteRx();
 32c:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
 330:	18 2f       	mov	r17, r24
   byteTx(OC_READ_SENSORS);
 332:	8e e8       	ldi	r24, 0x8E	; 142
 334:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(SEN_CLIFF_R);
 338:	8c e0       	ldi	r24, 0x0C	; 12
 33a:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   uint8_t cliffR = byteRx();
 33e:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
   return (cliffL | cliffFL | cliffFR | cliffR);
 342:	0f 29       	or	r16, r15
 344:	01 2b       	or	r16, r17
}
 346:	80 2b       	or	r24, r16
 348:	90 e0       	ldi	r25, 0x00	; 0
 34a:	1f 91       	pop	r17
 34c:	0f 91       	pop	r16
 34e:	ff 90       	pop	r15
 350:	08 95       	ret

00000352 <dropTrigger>:
   triggered. Returns a 1 if one has or a 0 if none
   have */

int dropTrigger(void)
{
  byteTx(OC_READ_SENSORS);
 352:	8e e8       	ldi	r24, 0x8E	; 142
 354:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
  byteTx(SEN_BUMPS_AND_WHEELS_DROP);
 358:	87 e0       	ldi	r24, 0x07	; 7
 35a:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
  uint8_t bumpDrop = byteRx();
 35e:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
  return ((bumpDrop & 4) || (bumpDrop & 8) || (bumpDrop & 16));
 362:	90 e0       	ldi	r25, 0x00	; 0

/* Checks to see if any of the drop sensors have been
   triggered. Returns a 1 if one has or a 0 if none
   have */

int dropTrigger(void)
 364:	9c 01       	movw	r18, r24
 366:	2c 70       	andi	r18, 0x0C	; 12
 368:	30 70       	andi	r19, 0x00	; 0
{
  byteTx(OC_READ_SENSORS);
  byteTx(SEN_BUMPS_AND_WHEELS_DROP);
  uint8_t bumpDrop = byteRx();
  return ((bumpDrop & 4) || (bumpDrop & 8) || (bumpDrop & 16));
 36a:	21 15       	cp	r18, r1
 36c:	31 05       	cpc	r19, r1
 36e:	39 f4       	brne	.+14     	; 0x37e <dropTrigger+0x2c>
 370:	21 e0       	ldi	r18, 0x01	; 1
 372:	30 e0       	ldi	r19, 0x00	; 0
 374:	84 fd       	sbrc	r24, 4
 376:	05 c0       	rjmp	.+10     	; 0x382 <dropTrigger+0x30>
 378:	20 e0       	ldi	r18, 0x00	; 0
 37a:	30 e0       	ldi	r19, 0x00	; 0
 37c:	02 c0       	rjmp	.+4      	; 0x382 <dropTrigger+0x30>
 37e:	21 e0       	ldi	r18, 0x01	; 1
 380:	30 e0       	ldi	r19, 0x00	; 0
}
 382:	c9 01       	movw	r24, r18
 384:	08 95       	ret

00000386 <getRemote>:

/* Returns the value of the remote sensor */

int getRemote(void)
{
   byteTx(OC_READ_SENSORS);
 386:	8e e8       	ldi	r24, 0x8E	; 142
 388:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(SEN_REMOTE);
 38c:	81 e1       	ldi	r24, 0x11	; 17
 38e:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   return byteRx();
 392:	0e 94 c1 00 	call	0x182	; 0x182 <byteRx>
}
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	08 95       	ret

0000039a <print>:
   character in that array until it reaches the null
   character that is present at the end of every string.
   After which, it will return a new line */

void print(const char *in)
{
 39a:	ef 92       	push	r14
 39c:	ff 92       	push	r15
 39e:	cf 93       	push	r28
 3a0:	df 93       	push	r29
 3a2:	e8 2e       	mov	r14, r24
 3a4:	e7 01       	movw	r28, r14
 3a6:	7e 01       	movw	r14, r28
 3a8:	f9 2e       	mov	r15, r25
 3aa:	e7 01       	movw	r28, r14
   int i = 0;
   while(in[i] != '\0')
 3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <print+0x18>
   {
      byteTx(in[i]);
 3ae:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   After which, it will return a new line */

void print(const char *in)
{
   int i = 0;
   while(in[i] != '\0')
 3b2:	89 91       	ld	r24, Y+
 3b4:	88 23       	and	r24, r24
 3b6:	d9 f7       	brne	.-10     	; 0x3ae <print+0x14>
   {
      byteTx(in[i]);
      i++;
   }
   byteTx('\n');
 3b8:	8a e0       	ldi	r24, 0x0A	; 10
 3ba:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 3be:	df 91       	pop	r29
 3c0:	cf 91       	pop	r28
 3c2:	ff 90       	pop	r15
 3c4:	ef 90       	pop	r14
 3c6:	08 95       	ret

000003c8 <sendSensors>:

/* Sends a query with 6 packets for various sensor */

void sendSensors(void)
{
   byteTx(OC_QUERY);
 3c8:	85 e9       	ldi	r24, 0x95	; 149
 3ca:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(PACKET_NUMBERS);
 3ce:	86 e0       	ldi	r24, 0x06	; 6
 3d0:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_BATTERY_CHARGE);
 3d4:	89 e1       	ldi	r24, 0x19	; 25
 3d6:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_WALL_SENSOR);
 3da:	8b e1       	ldi	r24, 0x1B	; 27
 3dc:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_CLIFF_L);
 3e0:	8c e1       	ldi	r24, 0x1C	; 28
 3e2:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_CLIFF_FL);
 3e6:	8d e1       	ldi	r24, 0x1D	; 29
 3e8:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_CLIFF_FR);
 3ec:	8e e1       	ldi	r24, 0x1E	; 30
 3ee:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(Q_CLIFF_R);
 3f2:	8f e1       	ldi	r24, 0x1F	; 31
 3f4:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 3f8:	08 95       	ret

000003fa <getSensors>:
/* Gets the value of the 6 sensor readings */

void getSensors(uint16_t *bCO, uint16_t *wSO, 
                uint16_t *cLO, uint16_t *cFLO, 
                uint16_t *cFRO, uint16_t *cRO)
{
 3fa:	6f 92       	push	r6
 3fc:	7f 92       	push	r7
 3fe:	8f 92       	push	r8
 400:	9f 92       	push	r9
 402:	af 92       	push	r10
 404:	bf 92       	push	r11
 406:	cf 92       	push	r12
 408:	df 92       	push	r13
 40a:	ef 92       	push	r14
 40c:	ff 92       	push	r15
 40e:	0f 93       	push	r16
 410:	1f 93       	push	r17
 412:	cf 93       	push	r28
 414:	df 93       	push	r29
 416:	3c 01       	movw	r6, r24
 418:	4b 01       	movw	r8, r22
 41a:	5a 01       	movw	r10, r20
 41c:	69 01       	movw	r12, r18
 41e:	e8 01       	movw	r28, r16
   *bCO  = byteRx16();
 420:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 424:	f3 01       	movw	r30, r6
 426:	91 83       	std	Z+1, r25	; 0x01
 428:	80 83       	st	Z, r24
   *wSO  = byteRx16();
 42a:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 42e:	f4 01       	movw	r30, r8
 430:	91 83       	std	Z+1, r25	; 0x01
 432:	80 83       	st	Z, r24
   *cLO  = byteRx16();
 434:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 438:	f5 01       	movw	r30, r10
 43a:	91 83       	std	Z+1, r25	; 0x01
 43c:	80 83       	st	Z, r24
   *cFLO = byteRx16();
 43e:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 442:	f6 01       	movw	r30, r12
 444:	91 83       	std	Z+1, r25	; 0x01
 446:	80 83       	st	Z, r24
   *cFRO = byteRx16();
 448:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 44c:	99 83       	std	Y+1, r25	; 0x01
 44e:	88 83       	st	Y, r24
   *cRO  = byteRx16();
 450:	0e 94 c8 00 	call	0x190	; 0x190 <byteRx16>
 454:	f7 01       	movw	r30, r14
 456:	91 83       	std	Z+1, r25	; 0x01
 458:	80 83       	st	Z, r24
}
 45a:	df 91       	pop	r29
 45c:	cf 91       	pop	r28
 45e:	1f 91       	pop	r17
 460:	0f 91       	pop	r16
 462:	ff 90       	pop	r15
 464:	ef 90       	pop	r14
 466:	df 90       	pop	r13
 468:	cf 90       	pop	r12
 46a:	bf 90       	pop	r11
 46c:	af 90       	pop	r10
 46e:	9f 90       	pop	r9
 470:	8f 90       	pop	r8
 472:	7f 90       	pop	r7
 474:	6f 90       	pop	r6
 476:	08 95       	ret

00000478 <createRedLED>:

/* Basic functionality to turn the power LED to red */

void createRedLED(void)
{
   byteTx(OC_SETLEDS);
 478:	8b e8       	ldi	r24, 0x8B	; 139
 47a:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_BOTHOFF);
 47e:	80 e0       	ldi	r24, 0x00	; 0
 480:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_FULLRED);
 484:	8f ef       	ldi	r24, 0xFF	; 255
 486:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_FULLINTENSE);
 48a:	8f ef       	ldi	r24, 0xFF	; 255
 48c:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 490:	08 95       	ret

00000492 <initialize>:
   Power LED to red */

void initialize(void)
{
   // Disable interrupts
   cli();
 492:	f8 94       	cli
   for port D to one. This sets pin 5 of Port D, which
   controls the right LED, to output mode. Done once before
   calling rightLEDOn() */
void setupRightLED(void)
{
   DDRD != (1 << 5);
 494:	8a b1       	in	r24, 0x0a	; 10
   for port D to one. This sets pin 6 of Port D, which
   controls the left LED, to output mode. Done once before
   calling leftLEDOn() */
void setupLeftLED(void)
{
   DDRD != (1 << 6);
 496:	8a b1       	in	r24, 0x0a	; 10
   cli();

   // One-time setup
   setupRightLED();
   setupLeftLED();
   setupSerialPort();
 498:	0e 94 ad 00 	call	0x15a	; 0x15a <setupSerialPort>
   setupTimer();
 49c:	0e 94 5f 00 	call	0xbe	; 0xbe <setupTimer>

   // Enable interrupts
   sei();
 4a0:	78 94       	sei
   byteTx(OC_START);
 4a2:	80 e8       	ldi	r24, 0x80	; 128
 4a4:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(OC_FULL_MODE);
 4a8:	84 e8       	ldi	r24, 0x84	; 132
 4aa:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>

   createRedLED();
 4ae:	0e 94 3c 02 	call	0x478	; 0x478 <createRedLED>
}
 4b2:	08 95       	ret

000004b4 <createOrangeLED>:

/* Basic functionality to turn the power LED to orange */

void createOrangeLED(void)
{
   byteTx(OC_SETLEDS);
 4b4:	8b e8       	ldi	r24, 0x8B	; 139
 4b6:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_BOTHOFF);
 4ba:	80 e0       	ldi	r24, 0x00	; 0
 4bc:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_ORANGE);
 4c0:	88 e2       	ldi	r24, 0x28	; 40
 4c2:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
   byteTx(LED_FULLINTENSE);
 4c6:	8f ef       	ldi	r24, 0xFF	; 255
 4c8:	0e 94 ba 00 	call	0x174	; 0x174 <byteTx>
}
 4cc:	08 95       	ret

000004ce <checkTurn>:
   for the robot to turn. If it is not safe, the LED
   will be a solid orange color */

int checkTurn(void)
{
   if(dropTrigger() == 1) 
 4ce:	0e 94 a9 01 	call	0x352	; 0x352 <dropTrigger>
 4d2:	81 30       	cpi	r24, 0x01	; 1
 4d4:	91 05       	cpc	r25, r1
 4d6:	29 f4       	brne	.+10     	; 0x4e2 <checkTurn+0x14>
   {
      createOrangeLED();
 4d8:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <createOrangeLED>
      return 0;
 4dc:	20 e0       	ldi	r18, 0x00	; 0
 4de:	30 e0       	ldi	r19, 0x00	; 0
 4e0:	04 c0       	rjmp	.+8      	; 0x4ea <checkTurn+0x1c>
   }
   else
   {
      createRedLED();
 4e2:	0e 94 3c 02 	call	0x478	; 0x478 <createRedLED>
      return 1;
 4e6:	21 e0       	ldi	r18, 0x01	; 1
 4e8:	30 e0       	ldi	r19, 0x00	; 0
   }
}
 4ea:	c9 01       	movw	r24, r18
 4ec:	08 95       	ret

000004ee <checkForward>:
   determine if it is safe for the robot to move forward.
   If it is not safe, the LED will blink red-orange. */

int checkForward(void)
{
    if((!bumpTrigger()) && (!dropTrigger()) && 
 4ee:	0e 94 66 01 	call	0x2cc	; 0x2cc <bumpTrigger>
 4f2:	00 97       	sbiw	r24, 0x00	; 0
 4f4:	69 f4       	brne	.+26     	; 0x510 <__stack+0x11>
 4f6:	0e 94 a9 01 	call	0x352	; 0x352 <dropTrigger>
 4fa:	00 97       	sbiw	r24, 0x00	; 0
 4fc:	49 f4       	brne	.+18     	; 0x510 <__stack+0x11>
       (!cliffTrigger()))
 4fe:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <cliffTrigger>
   determine if it is safe for the robot to move forward.
   If it is not safe, the LED will blink red-orange. */

int checkForward(void)
{
    if((!bumpTrigger()) && (!dropTrigger()) && 
 502:	00 97       	sbiw	r24, 0x00	; 0
 504:	29 f4       	brne	.+10     	; 0x510 <__stack+0x11>
       (!cliffTrigger()))
    {
        createRedLED();
 506:	0e 94 3c 02 	call	0x478	; 0x478 <createRedLED>
        return 1;
 50a:	21 e0       	ldi	r18, 0x01	; 1
 50c:	30 e0       	ldi	r19, 0x00	; 0
 50e:	04 c0       	rjmp	.+8      	; 0x518 <__stack+0x19>
    } 
    else
    {
        createOrangeLED();
 510:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <createOrangeLED>
        return 0;
 514:	20 e0       	ldi	r18, 0x00	; 0
 516:	30 e0       	ldi	r19, 0x00	; 0
    }
}
 518:	c9 01       	movw	r24, r18
 51a:	08 95       	ret

0000051c <main>:
#include <avr/interrupt.h>
#include "driveCommands.h"
#include "OI.h"

int main(void)
{
 51c:	2f 92       	push	r2
 51e:	3f 92       	push	r3
 520:	4f 92       	push	r4
 522:	5f 92       	push	r5
 524:	6f 92       	push	r6
 526:	7f 92       	push	r7
 528:	8f 92       	push	r8
 52a:	9f 92       	push	r9
 52c:	af 92       	push	r10
 52e:	bf 92       	push	r11
 530:	cf 92       	push	r12
 532:	df 92       	push	r13
 534:	ef 92       	push	r14
 536:	ff 92       	push	r15
 538:	0f 93       	push	r16
 53a:	1f 93       	push	r17
 53c:	df 93       	push	r29
 53e:	cf 93       	push	r28
 540:	cd b7       	in	r28, 0x3d	; 61
 542:	de b7       	in	r29, 0x3e	; 62
 544:	c0 57       	subi	r28, 0x70	; 112
 546:	d0 40       	sbci	r29, 0x00	; 0
 548:	0f b6       	in	r0, 0x3f	; 63
 54a:	f8 94       	cli
 54c:	de bf       	out	0x3e, r29	; 62
 54e:	0f be       	out	0x3f, r0	; 63
 550:	cd bf       	out	0x3d, r28	; 61
   uint16_t bCO, wSO, cLO, cFLO, cFRO, cRO;
   char myBuffer[100];
   initialize();
 552:	0e 94 49 02 	call	0x492	; 0x492 <initialize>
         setSerialDestination(SERIAL_CREATE);
         /* (1.1) Read the robot's battery charge, wall signal
            and the four cliff sensor values.*/
	 sendSensors();

         getSensors(&bCO, &wSO, &cLO, &cFLO, 
 556:	03 e0       	ldi	r16, 0x03	; 3
 558:	60 2e       	mov	r6, r16
 55a:	71 2c       	mov	r7, r1
 55c:	6c 0e       	add	r6, r28
 55e:	7d 1e       	adc	r7, r29
 560:	15 e0       	ldi	r17, 0x05	; 5
 562:	41 2e       	mov	r4, r17
 564:	51 2c       	mov	r5, r1
 566:	4c 0e       	add	r4, r28
 568:	5d 1e       	adc	r5, r29
 56a:	b7 e0       	ldi	r27, 0x07	; 7
 56c:	2b 2e       	mov	r2, r27
 56e:	31 2c       	mov	r3, r1
 570:	2c 0e       	add	r2, r28
 572:	3d 1e       	adc	r3, r29
 574:	a9 e0       	ldi	r26, 0x09	; 9
 576:	aa 2e       	mov	r10, r26
 578:	b1 2c       	mov	r11, r1
 57a:	ac 0e       	add	r10, r28
 57c:	bd 1e       	adc	r11, r29
 57e:	4e 01       	movw	r8, r28
 580:	08 94       	sec
 582:	81 1c       	adc	r8, r1
 584:	91 1c       	adc	r9, r1
         setSerialDestination(SERIAL_USB); 
        
         /* (1.2) Display those sensor values in a human-
            readable format, identified with English text
            strings, on the workstation's screen. */
         sprintf(myBuffer,"This is the battery charge: %u", bCO);
 586:	fd e0       	ldi	r31, 0x0D	; 13
 588:	cf 2e       	mov	r12, r31
 58a:	d1 2c       	mov	r13, r1
 58c:	cc 0e       	add	r12, r28
 58e:	dd 1e       	adc	r13, r29
   char myBuffer[100];
   initialize();

   for(;;)
   {
      if(responseTimer == 0)
 590:	80 91 00 01 	lds	r24, 0x0100
 594:	90 91 01 01 	lds	r25, 0x0101
 598:	00 97       	sbiw	r24, 0x00	; 0
 59a:	d1 f7       	brne	.-12     	; 0x590 <main+0x74>
      {
         setSerialDestination(SERIAL_CREATE);
 59c:	81 e0       	ldi	r24, 0x01	; 1
 59e:	0e 94 55 01 	call	0x2aa	; 0x2aa <setSerialDestination>
         /* (1.1) Read the robot's battery charge, wall signal
            and the four cliff sensor values.*/
	 sendSensors();
 5a2:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <sendSensors>

         getSensors(&bCO, &wSO, &cLO, &cFLO, 
 5a6:	c4 01       	movw	r24, r8
 5a8:	b3 01       	movw	r22, r6
 5aa:	a2 01       	movw	r20, r4
 5ac:	91 01       	movw	r18, r2
 5ae:	85 01       	movw	r16, r10
 5b0:	eb e0       	ldi	r30, 0x0B	; 11
 5b2:	ee 2e       	mov	r14, r30
 5b4:	f1 2c       	mov	r15, r1
 5b6:	ec 0e       	add	r14, r28
 5b8:	fd 1e       	adc	r15, r29
 5ba:	0e 94 fd 01 	call	0x3fa	; 0x3fa <getSensors>
                    &cFRO, &cRO);
         
         setSerialDestination(SERIAL_USB); 
 5be:	82 e0       	ldi	r24, 0x02	; 2
 5c0:	0e 94 55 01 	call	0x2aa	; 0x2aa <setSerialDestination>
        
         /* (1.2) Display those sensor values in a human-
            readable format, identified with English text
            strings, on the workstation's screen. */
         sprintf(myBuffer,"This is the battery charge: %u", bCO);
 5c4:	00 d0       	rcall	.+0      	; 0x5c6 <main+0xaa>
 5c6:	00 d0       	rcall	.+0      	; 0x5c8 <main+0xac>
 5c8:	00 d0       	rcall	.+0      	; 0x5ca <main+0xae>
 5ca:	ed b7       	in	r30, 0x3d	; 61
 5cc:	fe b7       	in	r31, 0x3e	; 62
 5ce:	31 96       	adiw	r30, 0x01	; 1
 5d0:	ad b7       	in	r26, 0x3d	; 61
 5d2:	be b7       	in	r27, 0x3e	; 62
 5d4:	12 96       	adiw	r26, 0x02	; 2
 5d6:	dc 92       	st	X, r13
 5d8:	ce 92       	st	-X, r12
 5da:	11 97       	sbiw	r26, 0x01	; 1
 5dc:	82 e0       	ldi	r24, 0x02	; 2
 5de:	91 e0       	ldi	r25, 0x01	; 1
 5e0:	93 83       	std	Z+3, r25	; 0x03
 5e2:	82 83       	std	Z+2, r24	; 0x02
 5e4:	89 81       	ldd	r24, Y+1	; 0x01
 5e6:	9a 81       	ldd	r25, Y+2	; 0x02
 5e8:	95 83       	std	Z+5, r25	; 0x05
 5ea:	84 83       	std	Z+4, r24	; 0x04
 5ec:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
	 print(myBuffer);
 5f0:	ad b7       	in	r26, 0x3d	; 61
 5f2:	be b7       	in	r27, 0x3e	; 62
 5f4:	16 96       	adiw	r26, 0x06	; 6
 5f6:	0f b6       	in	r0, 0x3f	; 63
 5f8:	f8 94       	cli
 5fa:	be bf       	out	0x3e, r27	; 62
 5fc:	0f be       	out	0x3f, r0	; 63
 5fe:	ad bf       	out	0x3d, r26	; 61
 600:	c6 01       	movw	r24, r12
 602:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer,"This is the wall sensor: %u", wSO);
 606:	00 d0       	rcall	.+0      	; 0x608 <main+0xec>
 608:	00 d0       	rcall	.+0      	; 0x60a <main+0xee>
 60a:	00 d0       	rcall	.+0      	; 0x60c <main+0xf0>
 60c:	ed b7       	in	r30, 0x3d	; 61
 60e:	fe b7       	in	r31, 0x3e	; 62
 610:	31 96       	adiw	r30, 0x01	; 1
 612:	ad b7       	in	r26, 0x3d	; 61
 614:	be b7       	in	r27, 0x3e	; 62
 616:	12 96       	adiw	r26, 0x02	; 2
 618:	dc 92       	st	X, r13
 61a:	ce 92       	st	-X, r12
 61c:	11 97       	sbiw	r26, 0x01	; 1
 61e:	81 e2       	ldi	r24, 0x21	; 33
 620:	91 e0       	ldi	r25, 0x01	; 1
 622:	93 83       	std	Z+3, r25	; 0x03
 624:	82 83       	std	Z+2, r24	; 0x02
 626:	8b 81       	ldd	r24, Y+3	; 0x03
 628:	9c 81       	ldd	r25, Y+4	; 0x04
 62a:	95 83       	std	Z+5, r25	; 0x05
 62c:	84 83       	std	Z+4, r24	; 0x04
 62e:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
         print(myBuffer);
 632:	ad b7       	in	r26, 0x3d	; 61
 634:	be b7       	in	r27, 0x3e	; 62
 636:	16 96       	adiw	r26, 0x06	; 6
 638:	0f b6       	in	r0, 0x3f	; 63
 63a:	f8 94       	cli
 63c:	be bf       	out	0x3e, r27	; 62
 63e:	0f be       	out	0x3f, r0	; 63
 640:	ad bf       	out	0x3d, r26	; 61
 642:	c6 01       	movw	r24, r12
 644:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer, "This is the left cliff sensor: %u", cLO);
 648:	00 d0       	rcall	.+0      	; 0x64a <main+0x12e>
 64a:	00 d0       	rcall	.+0      	; 0x64c <main+0x130>
 64c:	00 d0       	rcall	.+0      	; 0x64e <main+0x132>
 64e:	ed b7       	in	r30, 0x3d	; 61
 650:	fe b7       	in	r31, 0x3e	; 62
 652:	31 96       	adiw	r30, 0x01	; 1
 654:	ad b7       	in	r26, 0x3d	; 61
 656:	be b7       	in	r27, 0x3e	; 62
 658:	12 96       	adiw	r26, 0x02	; 2
 65a:	dc 92       	st	X, r13
 65c:	ce 92       	st	-X, r12
 65e:	11 97       	sbiw	r26, 0x01	; 1
 660:	8d e3       	ldi	r24, 0x3D	; 61
 662:	91 e0       	ldi	r25, 0x01	; 1
 664:	93 83       	std	Z+3, r25	; 0x03
 666:	82 83       	std	Z+2, r24	; 0x02
 668:	8d 81       	ldd	r24, Y+5	; 0x05
 66a:	9e 81       	ldd	r25, Y+6	; 0x06
 66c:	95 83       	std	Z+5, r25	; 0x05
 66e:	84 83       	std	Z+4, r24	; 0x04
 670:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
         print(myBuffer);
 674:	ad b7       	in	r26, 0x3d	; 61
 676:	be b7       	in	r27, 0x3e	; 62
 678:	16 96       	adiw	r26, 0x06	; 6
 67a:	0f b6       	in	r0, 0x3f	; 63
 67c:	f8 94       	cli
 67e:	be bf       	out	0x3e, r27	; 62
 680:	0f be       	out	0x3f, r0	; 63
 682:	ad bf       	out	0x3d, r26	; 61
 684:	c6 01       	movw	r24, r12
 686:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer, "This is the front left cliff sensor: %u", cFLO);
 68a:	00 d0       	rcall	.+0      	; 0x68c <main+0x170>
 68c:	00 d0       	rcall	.+0      	; 0x68e <main+0x172>
 68e:	00 d0       	rcall	.+0      	; 0x690 <main+0x174>
 690:	ed b7       	in	r30, 0x3d	; 61
 692:	fe b7       	in	r31, 0x3e	; 62
 694:	31 96       	adiw	r30, 0x01	; 1
 696:	ad b7       	in	r26, 0x3d	; 61
 698:	be b7       	in	r27, 0x3e	; 62
 69a:	12 96       	adiw	r26, 0x02	; 2
 69c:	dc 92       	st	X, r13
 69e:	ce 92       	st	-X, r12
 6a0:	11 97       	sbiw	r26, 0x01	; 1
 6a2:	8f e5       	ldi	r24, 0x5F	; 95
 6a4:	91 e0       	ldi	r25, 0x01	; 1
 6a6:	93 83       	std	Z+3, r25	; 0x03
 6a8:	82 83       	std	Z+2, r24	; 0x02
 6aa:	8f 81       	ldd	r24, Y+7	; 0x07
 6ac:	98 85       	ldd	r25, Y+8	; 0x08
 6ae:	95 83       	std	Z+5, r25	; 0x05
 6b0:	84 83       	std	Z+4, r24	; 0x04
 6b2:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
         print(myBuffer);
 6b6:	ad b7       	in	r26, 0x3d	; 61
 6b8:	be b7       	in	r27, 0x3e	; 62
 6ba:	16 96       	adiw	r26, 0x06	; 6
 6bc:	0f b6       	in	r0, 0x3f	; 63
 6be:	f8 94       	cli
 6c0:	be bf       	out	0x3e, r27	; 62
 6c2:	0f be       	out	0x3f, r0	; 63
 6c4:	ad bf       	out	0x3d, r26	; 61
 6c6:	c6 01       	movw	r24, r12
 6c8:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer, "This is the front right cliff sensor: %u", cFRO);
 6cc:	00 d0       	rcall	.+0      	; 0x6ce <main+0x1b2>
 6ce:	00 d0       	rcall	.+0      	; 0x6d0 <main+0x1b4>
 6d0:	00 d0       	rcall	.+0      	; 0x6d2 <main+0x1b6>
 6d2:	ed b7       	in	r30, 0x3d	; 61
 6d4:	fe b7       	in	r31, 0x3e	; 62
 6d6:	31 96       	adiw	r30, 0x01	; 1
 6d8:	ad b7       	in	r26, 0x3d	; 61
 6da:	be b7       	in	r27, 0x3e	; 62
 6dc:	12 96       	adiw	r26, 0x02	; 2
 6de:	dc 92       	st	X, r13
 6e0:	ce 92       	st	-X, r12
 6e2:	11 97       	sbiw	r26, 0x01	; 1
 6e4:	87 e8       	ldi	r24, 0x87	; 135
 6e6:	91 e0       	ldi	r25, 0x01	; 1
 6e8:	93 83       	std	Z+3, r25	; 0x03
 6ea:	82 83       	std	Z+2, r24	; 0x02
 6ec:	89 85       	ldd	r24, Y+9	; 0x09
 6ee:	9a 85       	ldd	r25, Y+10	; 0x0a
 6f0:	95 83       	std	Z+5, r25	; 0x05
 6f2:	84 83       	std	Z+4, r24	; 0x04
 6f4:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
         print(myBuffer);
 6f8:	ad b7       	in	r26, 0x3d	; 61
 6fa:	be b7       	in	r27, 0x3e	; 62
 6fc:	16 96       	adiw	r26, 0x06	; 6
 6fe:	0f b6       	in	r0, 0x3f	; 63
 700:	f8 94       	cli
 702:	be bf       	out	0x3e, r27	; 62
 704:	0f be       	out	0x3f, r0	; 63
 706:	ad bf       	out	0x3d, r26	; 61
 708:	c6 01       	movw	r24, r12
 70a:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer, "This is the right cliff sensor: %u", cRO);
 70e:	00 d0       	rcall	.+0      	; 0x710 <main+0x1f4>
 710:	00 d0       	rcall	.+0      	; 0x712 <main+0x1f6>
 712:	00 d0       	rcall	.+0      	; 0x714 <main+0x1f8>
 714:	ed b7       	in	r30, 0x3d	; 61
 716:	fe b7       	in	r31, 0x3e	; 62
 718:	31 96       	adiw	r30, 0x01	; 1
 71a:	ad b7       	in	r26, 0x3d	; 61
 71c:	be b7       	in	r27, 0x3e	; 62
 71e:	12 96       	adiw	r26, 0x02	; 2
 720:	dc 92       	st	X, r13
 722:	ce 92       	st	-X, r12
 724:	11 97       	sbiw	r26, 0x01	; 1
 726:	80 eb       	ldi	r24, 0xB0	; 176
 728:	91 e0       	ldi	r25, 0x01	; 1
 72a:	93 83       	std	Z+3, r25	; 0x03
 72c:	82 83       	std	Z+2, r24	; 0x02
 72e:	8b 85       	ldd	r24, Y+11	; 0x0b
 730:	9c 85       	ldd	r25, Y+12	; 0x0c
 732:	95 83       	std	Z+5, r25	; 0x05
 734:	84 83       	std	Z+4, r24	; 0x04
 736:	0e 94 be 03 	call	0x77c	; 0x77c <sprintf>
         print(myBuffer);
 73a:	ad b7       	in	r26, 0x3d	; 61
 73c:	be b7       	in	r27, 0x3e	; 62
 73e:	16 96       	adiw	r26, 0x06	; 6
 740:	0f b6       	in	r0, 0x3f	; 63
 742:	f8 94       	cli
 744:	be bf       	out	0x3e, r27	; 62
 746:	0f be       	out	0x3f, r0	; 63
 748:	ad bf       	out	0x3d, r26	; 61
 74a:	c6 01       	movw	r24, r12
 74c:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         sprintf(myBuffer, "\n");
 750:	c6 01       	movw	r24, r12
 752:	63 ed       	ldi	r22, 0xD3	; 211
 754:	71 e0       	ldi	r23, 0x01	; 1
 756:	0e 94 b7 03 	call	0x76e	; 0x76e <strcpy>
         print(myBuffer);
 75a:	c6 01       	movw	r24, r12
 75c:	0e 94 cd 01 	call	0x39a	; 0x39a <print>
         
         /* (1.3) Repeat once per second */
         responseTimer = RESPONSE_TIMER_RESET;
 760:	88 ee       	ldi	r24, 0xE8	; 232
 762:	93 e0       	ldi	r25, 0x03	; 3
 764:	90 93 01 01 	sts	0x0101, r25
 768:	80 93 00 01 	sts	0x0100, r24
 76c:	11 cf       	rjmp	.-478    	; 0x590 <main+0x74>

0000076e <strcpy>:
 76e:	fb 01       	movw	r30, r22
 770:	dc 01       	movw	r26, r24
 772:	01 90       	ld	r0, Z+
 774:	0d 92       	st	X+, r0
 776:	00 20       	and	r0, r0
 778:	e1 f7       	brne	.-8      	; 0x772 <strcpy+0x4>
 77a:	08 95       	ret

0000077c <sprintf>:
 77c:	ae e0       	ldi	r26, 0x0E	; 14
 77e:	b0 e0       	ldi	r27, 0x00	; 0
 780:	e4 ec       	ldi	r30, 0xC4	; 196
 782:	f3 e0       	ldi	r31, 0x03	; 3
 784:	0c 94 76 06 	jmp	0xcec	; 0xcec <__prologue_saves__+0x1c>
 788:	0d 89       	ldd	r16, Y+21	; 0x15
 78a:	1e 89       	ldd	r17, Y+22	; 0x16
 78c:	86 e0       	ldi	r24, 0x06	; 6
 78e:	8c 83       	std	Y+4, r24	; 0x04
 790:	1a 83       	std	Y+2, r17	; 0x02
 792:	09 83       	std	Y+1, r16	; 0x01
 794:	8f ef       	ldi	r24, 0xFF	; 255
 796:	9f e7       	ldi	r25, 0x7F	; 127
 798:	9e 83       	std	Y+6, r25	; 0x06
 79a:	8d 83       	std	Y+5, r24	; 0x05
 79c:	9e 01       	movw	r18, r28
 79e:	27 5e       	subi	r18, 0xE7	; 231
 7a0:	3f 4f       	sbci	r19, 0xFF	; 255
 7a2:	ce 01       	movw	r24, r28
 7a4:	01 96       	adiw	r24, 0x01	; 1
 7a6:	6f 89       	ldd	r22, Y+23	; 0x17
 7a8:	78 8d       	ldd	r23, Y+24	; 0x18
 7aa:	a9 01       	movw	r20, r18
 7ac:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vfprintf>
 7b0:	ef 81       	ldd	r30, Y+7	; 0x07
 7b2:	f8 85       	ldd	r31, Y+8	; 0x08
 7b4:	e0 0f       	add	r30, r16
 7b6:	f1 1f       	adc	r31, r17
 7b8:	10 82       	st	Z, r1
 7ba:	2e 96       	adiw	r28, 0x0e	; 14
 7bc:	e4 e0       	ldi	r30, 0x04	; 4
 7be:	0c 94 92 06 	jmp	0xd24	; 0xd24 <__epilogue_restores__+0x1c>

000007c2 <vfprintf>:
 7c2:	ac e0       	ldi	r26, 0x0C	; 12
 7c4:	b0 e0       	ldi	r27, 0x00	; 0
 7c6:	e7 ee       	ldi	r30, 0xE7	; 231
 7c8:	f3 e0       	ldi	r31, 0x03	; 3
 7ca:	0c 94 68 06 	jmp	0xcd0	; 0xcd0 <__prologue_saves__>
 7ce:	6c 01       	movw	r12, r24
 7d0:	1b 01       	movw	r2, r22
 7d2:	8a 01       	movw	r16, r20
 7d4:	fc 01       	movw	r30, r24
 7d6:	17 82       	std	Z+7, r1	; 0x07
 7d8:	16 82       	std	Z+6, r1	; 0x06
 7da:	83 81       	ldd	r24, Z+3	; 0x03
 7dc:	81 ff       	sbrs	r24, 1
 7de:	d1 c1       	rjmp	.+930    	; 0xb82 <vfprintf+0x3c0>
 7e0:	2e 01       	movw	r4, r28
 7e2:	08 94       	sec
 7e4:	41 1c       	adc	r4, r1
 7e6:	51 1c       	adc	r5, r1
 7e8:	f6 01       	movw	r30, r12
 7ea:	93 81       	ldd	r25, Z+3	; 0x03
 7ec:	f1 01       	movw	r30, r2
 7ee:	93 fd       	sbrc	r25, 3
 7f0:	85 91       	lpm	r24, Z+
 7f2:	93 ff       	sbrs	r25, 3
 7f4:	81 91       	ld	r24, Z+
 7f6:	1f 01       	movw	r2, r30
 7f8:	88 23       	and	r24, r24
 7fa:	09 f4       	brne	.+2      	; 0x7fe <vfprintf+0x3c>
 7fc:	be c1       	rjmp	.+892    	; 0xb7a <vfprintf+0x3b8>
 7fe:	85 32       	cpi	r24, 0x25	; 37
 800:	39 f4       	brne	.+14     	; 0x810 <vfprintf+0x4e>
 802:	93 fd       	sbrc	r25, 3
 804:	85 91       	lpm	r24, Z+
 806:	93 ff       	sbrs	r25, 3
 808:	81 91       	ld	r24, Z+
 80a:	1f 01       	movw	r2, r30
 80c:	85 32       	cpi	r24, 0x25	; 37
 80e:	29 f4       	brne	.+10     	; 0x81a <vfprintf+0x58>
 810:	90 e0       	ldi	r25, 0x00	; 0
 812:	b6 01       	movw	r22, r12
 814:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 818:	e7 cf       	rjmp	.-50     	; 0x7e8 <vfprintf+0x26>
 81a:	ee 24       	eor	r14, r14
 81c:	ff 24       	eor	r15, r15
 81e:	20 e0       	ldi	r18, 0x00	; 0
 820:	20 32       	cpi	r18, 0x20	; 32
 822:	b0 f4       	brcc	.+44     	; 0x850 <vfprintf+0x8e>
 824:	8b 32       	cpi	r24, 0x2B	; 43
 826:	69 f0       	breq	.+26     	; 0x842 <vfprintf+0x80>
 828:	8c 32       	cpi	r24, 0x2C	; 44
 82a:	28 f4       	brcc	.+10     	; 0x836 <vfprintf+0x74>
 82c:	80 32       	cpi	r24, 0x20	; 32
 82e:	51 f0       	breq	.+20     	; 0x844 <vfprintf+0x82>
 830:	83 32       	cpi	r24, 0x23	; 35
 832:	71 f4       	brne	.+28     	; 0x850 <vfprintf+0x8e>
 834:	0b c0       	rjmp	.+22     	; 0x84c <vfprintf+0x8a>
 836:	8d 32       	cpi	r24, 0x2D	; 45
 838:	39 f0       	breq	.+14     	; 0x848 <vfprintf+0x86>
 83a:	80 33       	cpi	r24, 0x30	; 48
 83c:	49 f4       	brne	.+18     	; 0x850 <vfprintf+0x8e>
 83e:	21 60       	ori	r18, 0x01	; 1
 840:	2c c0       	rjmp	.+88     	; 0x89a <vfprintf+0xd8>
 842:	22 60       	ori	r18, 0x02	; 2
 844:	24 60       	ori	r18, 0x04	; 4
 846:	29 c0       	rjmp	.+82     	; 0x89a <vfprintf+0xd8>
 848:	28 60       	ori	r18, 0x08	; 8
 84a:	27 c0       	rjmp	.+78     	; 0x89a <vfprintf+0xd8>
 84c:	20 61       	ori	r18, 0x10	; 16
 84e:	25 c0       	rjmp	.+74     	; 0x89a <vfprintf+0xd8>
 850:	27 fd       	sbrc	r18, 7
 852:	2c c0       	rjmp	.+88     	; 0x8ac <vfprintf+0xea>
 854:	38 2f       	mov	r19, r24
 856:	30 53       	subi	r19, 0x30	; 48
 858:	3a 30       	cpi	r19, 0x0A	; 10
 85a:	98 f4       	brcc	.+38     	; 0x882 <vfprintf+0xc0>
 85c:	26 ff       	sbrs	r18, 6
 85e:	08 c0       	rjmp	.+16     	; 0x870 <vfprintf+0xae>
 860:	8e 2d       	mov	r24, r14
 862:	88 0f       	add	r24, r24
 864:	e8 2e       	mov	r14, r24
 866:	ee 0c       	add	r14, r14
 868:	ee 0c       	add	r14, r14
 86a:	e8 0e       	add	r14, r24
 86c:	e3 0e       	add	r14, r19
 86e:	15 c0       	rjmp	.+42     	; 0x89a <vfprintf+0xd8>
 870:	8f 2d       	mov	r24, r15
 872:	88 0f       	add	r24, r24
 874:	f8 2e       	mov	r15, r24
 876:	ff 0c       	add	r15, r15
 878:	ff 0c       	add	r15, r15
 87a:	f8 0e       	add	r15, r24
 87c:	f3 0e       	add	r15, r19
 87e:	20 62       	ori	r18, 0x20	; 32
 880:	0c c0       	rjmp	.+24     	; 0x89a <vfprintf+0xd8>
 882:	8e 32       	cpi	r24, 0x2E	; 46
 884:	21 f4       	brne	.+8      	; 0x88e <vfprintf+0xcc>
 886:	26 fd       	sbrc	r18, 6
 888:	78 c1       	rjmp	.+752    	; 0xb7a <vfprintf+0x3b8>
 88a:	20 64       	ori	r18, 0x40	; 64
 88c:	06 c0       	rjmp	.+12     	; 0x89a <vfprintf+0xd8>
 88e:	8c 36       	cpi	r24, 0x6C	; 108
 890:	11 f4       	brne	.+4      	; 0x896 <vfprintf+0xd4>
 892:	20 68       	ori	r18, 0x80	; 128
 894:	02 c0       	rjmp	.+4      	; 0x89a <vfprintf+0xd8>
 896:	88 36       	cpi	r24, 0x68	; 104
 898:	49 f4       	brne	.+18     	; 0x8ac <vfprintf+0xea>
 89a:	f1 01       	movw	r30, r2
 89c:	93 fd       	sbrc	r25, 3
 89e:	85 91       	lpm	r24, Z+
 8a0:	93 ff       	sbrs	r25, 3
 8a2:	81 91       	ld	r24, Z+
 8a4:	1f 01       	movw	r2, r30
 8a6:	88 23       	and	r24, r24
 8a8:	09 f0       	breq	.+2      	; 0x8ac <vfprintf+0xea>
 8aa:	ba cf       	rjmp	.-140    	; 0x820 <vfprintf+0x5e>
 8ac:	98 2f       	mov	r25, r24
 8ae:	95 54       	subi	r25, 0x45	; 69
 8b0:	93 30       	cpi	r25, 0x03	; 3
 8b2:	18 f0       	brcs	.+6      	; 0x8ba <vfprintf+0xf8>
 8b4:	90 52       	subi	r25, 0x20	; 32
 8b6:	93 30       	cpi	r25, 0x03	; 3
 8b8:	28 f4       	brcc	.+10     	; 0x8c4 <vfprintf+0x102>
 8ba:	0c 5f       	subi	r16, 0xFC	; 252
 8bc:	1f 4f       	sbci	r17, 0xFF	; 255
 8be:	ff e3       	ldi	r31, 0x3F	; 63
 8c0:	f9 83       	std	Y+1, r31	; 0x01
 8c2:	0d c0       	rjmp	.+26     	; 0x8de <vfprintf+0x11c>
 8c4:	83 36       	cpi	r24, 0x63	; 99
 8c6:	31 f0       	breq	.+12     	; 0x8d4 <vfprintf+0x112>
 8c8:	83 37       	cpi	r24, 0x73	; 115
 8ca:	71 f0       	breq	.+28     	; 0x8e8 <vfprintf+0x126>
 8cc:	83 35       	cpi	r24, 0x53	; 83
 8ce:	09 f0       	breq	.+2      	; 0x8d2 <vfprintf+0x110>
 8d0:	60 c0       	rjmp	.+192    	; 0x992 <vfprintf+0x1d0>
 8d2:	22 c0       	rjmp	.+68     	; 0x918 <vfprintf+0x156>
 8d4:	f8 01       	movw	r30, r16
 8d6:	80 81       	ld	r24, Z
 8d8:	89 83       	std	Y+1, r24	; 0x01
 8da:	0e 5f       	subi	r16, 0xFE	; 254
 8dc:	1f 4f       	sbci	r17, 0xFF	; 255
 8de:	42 01       	movw	r8, r4
 8e0:	71 e0       	ldi	r23, 0x01	; 1
 8e2:	a7 2e       	mov	r10, r23
 8e4:	b1 2c       	mov	r11, r1
 8e6:	16 c0       	rjmp	.+44     	; 0x914 <vfprintf+0x152>
 8e8:	62 e0       	ldi	r22, 0x02	; 2
 8ea:	66 2e       	mov	r6, r22
 8ec:	71 2c       	mov	r7, r1
 8ee:	60 0e       	add	r6, r16
 8f0:	71 1e       	adc	r7, r17
 8f2:	f8 01       	movw	r30, r16
 8f4:	80 80       	ld	r8, Z
 8f6:	91 80       	ldd	r9, Z+1	; 0x01
 8f8:	26 ff       	sbrs	r18, 6
 8fa:	03 c0       	rjmp	.+6      	; 0x902 <vfprintf+0x140>
 8fc:	6e 2d       	mov	r22, r14
 8fe:	70 e0       	ldi	r23, 0x00	; 0
 900:	02 c0       	rjmp	.+4      	; 0x906 <vfprintf+0x144>
 902:	6f ef       	ldi	r22, 0xFF	; 255
 904:	7f ef       	ldi	r23, 0xFF	; 255
 906:	c4 01       	movw	r24, r8
 908:	2c 87       	std	Y+12, r18	; 0x0c
 90a:	0e 94 d3 05 	call	0xba6	; 0xba6 <strnlen>
 90e:	5c 01       	movw	r10, r24
 910:	83 01       	movw	r16, r6
 912:	2c 85       	ldd	r18, Y+12	; 0x0c
 914:	2f 77       	andi	r18, 0x7F	; 127
 916:	17 c0       	rjmp	.+46     	; 0x946 <vfprintf+0x184>
 918:	52 e0       	ldi	r21, 0x02	; 2
 91a:	65 2e       	mov	r6, r21
 91c:	71 2c       	mov	r7, r1
 91e:	60 0e       	add	r6, r16
 920:	71 1e       	adc	r7, r17
 922:	f8 01       	movw	r30, r16
 924:	80 80       	ld	r8, Z
 926:	91 80       	ldd	r9, Z+1	; 0x01
 928:	26 ff       	sbrs	r18, 6
 92a:	03 c0       	rjmp	.+6      	; 0x932 <vfprintf+0x170>
 92c:	6e 2d       	mov	r22, r14
 92e:	70 e0       	ldi	r23, 0x00	; 0
 930:	02 c0       	rjmp	.+4      	; 0x936 <vfprintf+0x174>
 932:	6f ef       	ldi	r22, 0xFF	; 255
 934:	7f ef       	ldi	r23, 0xFF	; 255
 936:	c4 01       	movw	r24, r8
 938:	2c 87       	std	Y+12, r18	; 0x0c
 93a:	0e 94 c8 05 	call	0xb90	; 0xb90 <strnlen_P>
 93e:	5c 01       	movw	r10, r24
 940:	2c 85       	ldd	r18, Y+12	; 0x0c
 942:	20 68       	ori	r18, 0x80	; 128
 944:	83 01       	movw	r16, r6
 946:	23 fd       	sbrc	r18, 3
 948:	20 c0       	rjmp	.+64     	; 0x98a <vfprintf+0x1c8>
 94a:	08 c0       	rjmp	.+16     	; 0x95c <vfprintf+0x19a>
 94c:	80 e2       	ldi	r24, 0x20	; 32
 94e:	90 e0       	ldi	r25, 0x00	; 0
 950:	b6 01       	movw	r22, r12
 952:	2c 87       	std	Y+12, r18	; 0x0c
 954:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 958:	fa 94       	dec	r15
 95a:	2c 85       	ldd	r18, Y+12	; 0x0c
 95c:	8f 2d       	mov	r24, r15
 95e:	90 e0       	ldi	r25, 0x00	; 0
 960:	a8 16       	cp	r10, r24
 962:	b9 06       	cpc	r11, r25
 964:	98 f3       	brcs	.-26     	; 0x94c <vfprintf+0x18a>
 966:	11 c0       	rjmp	.+34     	; 0x98a <vfprintf+0x1c8>
 968:	f4 01       	movw	r30, r8
 96a:	27 fd       	sbrc	r18, 7
 96c:	85 91       	lpm	r24, Z+
 96e:	27 ff       	sbrs	r18, 7
 970:	81 91       	ld	r24, Z+
 972:	4f 01       	movw	r8, r30
 974:	90 e0       	ldi	r25, 0x00	; 0
 976:	b6 01       	movw	r22, r12
 978:	2c 87       	std	Y+12, r18	; 0x0c
 97a:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 97e:	2c 85       	ldd	r18, Y+12	; 0x0c
 980:	f1 10       	cpse	r15, r1
 982:	fa 94       	dec	r15
 984:	08 94       	sec
 986:	a1 08       	sbc	r10, r1
 988:	b1 08       	sbc	r11, r1
 98a:	a1 14       	cp	r10, r1
 98c:	b1 04       	cpc	r11, r1
 98e:	61 f7       	brne	.-40     	; 0x968 <vfprintf+0x1a6>
 990:	f1 c0       	rjmp	.+482    	; 0xb74 <vfprintf+0x3b2>
 992:	84 36       	cpi	r24, 0x64	; 100
 994:	11 f0       	breq	.+4      	; 0x99a <vfprintf+0x1d8>
 996:	89 36       	cpi	r24, 0x69	; 105
 998:	49 f5       	brne	.+82     	; 0x9ec <vfprintf+0x22a>
 99a:	27 ff       	sbrs	r18, 7
 99c:	08 c0       	rjmp	.+16     	; 0x9ae <vfprintf+0x1ec>
 99e:	f8 01       	movw	r30, r16
 9a0:	60 81       	ld	r22, Z
 9a2:	71 81       	ldd	r23, Z+1	; 0x01
 9a4:	82 81       	ldd	r24, Z+2	; 0x02
 9a6:	93 81       	ldd	r25, Z+3	; 0x03
 9a8:	0c 5f       	subi	r16, 0xFC	; 252
 9aa:	1f 4f       	sbci	r17, 0xFF	; 255
 9ac:	09 c0       	rjmp	.+18     	; 0x9c0 <vfprintf+0x1fe>
 9ae:	f8 01       	movw	r30, r16
 9b0:	60 81       	ld	r22, Z
 9b2:	71 81       	ldd	r23, Z+1	; 0x01
 9b4:	88 27       	eor	r24, r24
 9b6:	77 fd       	sbrc	r23, 7
 9b8:	80 95       	com	r24
 9ba:	98 2f       	mov	r25, r24
 9bc:	0e 5f       	subi	r16, 0xFE	; 254
 9be:	1f 4f       	sbci	r17, 0xFF	; 255
 9c0:	4f e6       	ldi	r20, 0x6F	; 111
 9c2:	b4 2e       	mov	r11, r20
 9c4:	b2 22       	and	r11, r18
 9c6:	97 ff       	sbrs	r25, 7
 9c8:	09 c0       	rjmp	.+18     	; 0x9dc <vfprintf+0x21a>
 9ca:	90 95       	com	r25
 9cc:	80 95       	com	r24
 9ce:	70 95       	com	r23
 9d0:	61 95       	neg	r22
 9d2:	7f 4f       	sbci	r23, 0xFF	; 255
 9d4:	8f 4f       	sbci	r24, 0xFF	; 255
 9d6:	9f 4f       	sbci	r25, 0xFF	; 255
 9d8:	f0 e8       	ldi	r31, 0x80	; 128
 9da:	bf 2a       	or	r11, r31
 9dc:	a2 01       	movw	r20, r4
 9de:	2a e0       	ldi	r18, 0x0A	; 10
 9e0:	30 e0       	ldi	r19, 0x00	; 0
 9e2:	0e 94 0a 06 	call	0xc14	; 0xc14 <__ultoa_invert>
 9e6:	78 2e       	mov	r7, r24
 9e8:	74 18       	sub	r7, r4
 9ea:	45 c0       	rjmp	.+138    	; 0xa76 <vfprintf+0x2b4>
 9ec:	85 37       	cpi	r24, 0x75	; 117
 9ee:	31 f4       	brne	.+12     	; 0x9fc <vfprintf+0x23a>
 9f0:	3f ee       	ldi	r19, 0xEF	; 239
 9f2:	b3 2e       	mov	r11, r19
 9f4:	b2 22       	and	r11, r18
 9f6:	2a e0       	ldi	r18, 0x0A	; 10
 9f8:	30 e0       	ldi	r19, 0x00	; 0
 9fa:	25 c0       	rjmp	.+74     	; 0xa46 <vfprintf+0x284>
 9fc:	99 ef       	ldi	r25, 0xF9	; 249
 9fe:	b9 2e       	mov	r11, r25
 a00:	b2 22       	and	r11, r18
 a02:	8f 36       	cpi	r24, 0x6F	; 111
 a04:	c1 f0       	breq	.+48     	; 0xa36 <vfprintf+0x274>
 a06:	80 37       	cpi	r24, 0x70	; 112
 a08:	20 f4       	brcc	.+8      	; 0xa12 <vfprintf+0x250>
 a0a:	88 35       	cpi	r24, 0x58	; 88
 a0c:	09 f0       	breq	.+2      	; 0xa10 <vfprintf+0x24e>
 a0e:	b5 c0       	rjmp	.+362    	; 0xb7a <vfprintf+0x3b8>
 a10:	0d c0       	rjmp	.+26     	; 0xa2c <vfprintf+0x26a>
 a12:	80 37       	cpi	r24, 0x70	; 112
 a14:	21 f0       	breq	.+8      	; 0xa1e <vfprintf+0x25c>
 a16:	88 37       	cpi	r24, 0x78	; 120
 a18:	09 f0       	breq	.+2      	; 0xa1c <vfprintf+0x25a>
 a1a:	af c0       	rjmp	.+350    	; 0xb7a <vfprintf+0x3b8>
 a1c:	02 c0       	rjmp	.+4      	; 0xa22 <vfprintf+0x260>
 a1e:	20 e1       	ldi	r18, 0x10	; 16
 a20:	b2 2a       	or	r11, r18
 a22:	b4 fe       	sbrs	r11, 4
 a24:	0b c0       	rjmp	.+22     	; 0xa3c <vfprintf+0x27a>
 a26:	84 e0       	ldi	r24, 0x04	; 4
 a28:	b8 2a       	or	r11, r24
 a2a:	08 c0       	rjmp	.+16     	; 0xa3c <vfprintf+0x27a>
 a2c:	b4 fe       	sbrs	r11, 4
 a2e:	09 c0       	rjmp	.+18     	; 0xa42 <vfprintf+0x280>
 a30:	e6 e0       	ldi	r30, 0x06	; 6
 a32:	be 2a       	or	r11, r30
 a34:	06 c0       	rjmp	.+12     	; 0xa42 <vfprintf+0x280>
 a36:	28 e0       	ldi	r18, 0x08	; 8
 a38:	30 e0       	ldi	r19, 0x00	; 0
 a3a:	05 c0       	rjmp	.+10     	; 0xa46 <vfprintf+0x284>
 a3c:	20 e1       	ldi	r18, 0x10	; 16
 a3e:	30 e0       	ldi	r19, 0x00	; 0
 a40:	02 c0       	rjmp	.+4      	; 0xa46 <vfprintf+0x284>
 a42:	20 e1       	ldi	r18, 0x10	; 16
 a44:	32 e0       	ldi	r19, 0x02	; 2
 a46:	b7 fe       	sbrs	r11, 7
 a48:	08 c0       	rjmp	.+16     	; 0xa5a <vfprintf+0x298>
 a4a:	f8 01       	movw	r30, r16
 a4c:	60 81       	ld	r22, Z
 a4e:	71 81       	ldd	r23, Z+1	; 0x01
 a50:	82 81       	ldd	r24, Z+2	; 0x02
 a52:	93 81       	ldd	r25, Z+3	; 0x03
 a54:	0c 5f       	subi	r16, 0xFC	; 252
 a56:	1f 4f       	sbci	r17, 0xFF	; 255
 a58:	07 c0       	rjmp	.+14     	; 0xa68 <vfprintf+0x2a6>
 a5a:	f8 01       	movw	r30, r16
 a5c:	60 81       	ld	r22, Z
 a5e:	71 81       	ldd	r23, Z+1	; 0x01
 a60:	80 e0       	ldi	r24, 0x00	; 0
 a62:	90 e0       	ldi	r25, 0x00	; 0
 a64:	0e 5f       	subi	r16, 0xFE	; 254
 a66:	1f 4f       	sbci	r17, 0xFF	; 255
 a68:	a2 01       	movw	r20, r4
 a6a:	0e 94 0a 06 	call	0xc14	; 0xc14 <__ultoa_invert>
 a6e:	78 2e       	mov	r7, r24
 a70:	74 18       	sub	r7, r4
 a72:	ff e7       	ldi	r31, 0x7F	; 127
 a74:	bf 22       	and	r11, r31
 a76:	b6 fe       	sbrs	r11, 6
 a78:	0b c0       	rjmp	.+22     	; 0xa90 <vfprintf+0x2ce>
 a7a:	2e ef       	ldi	r18, 0xFE	; 254
 a7c:	b2 22       	and	r11, r18
 a7e:	7e 14       	cp	r7, r14
 a80:	38 f4       	brcc	.+14     	; 0xa90 <vfprintf+0x2ce>
 a82:	b4 fe       	sbrs	r11, 4
 a84:	07 c0       	rjmp	.+14     	; 0xa94 <vfprintf+0x2d2>
 a86:	b2 fc       	sbrc	r11, 2
 a88:	05 c0       	rjmp	.+10     	; 0xa94 <vfprintf+0x2d2>
 a8a:	8f ee       	ldi	r24, 0xEF	; 239
 a8c:	b8 22       	and	r11, r24
 a8e:	02 c0       	rjmp	.+4      	; 0xa94 <vfprintf+0x2d2>
 a90:	a7 2c       	mov	r10, r7
 a92:	01 c0       	rjmp	.+2      	; 0xa96 <vfprintf+0x2d4>
 a94:	ae 2c       	mov	r10, r14
 a96:	8b 2d       	mov	r24, r11
 a98:	90 e0       	ldi	r25, 0x00	; 0
 a9a:	b4 fe       	sbrs	r11, 4
 a9c:	0d c0       	rjmp	.+26     	; 0xab8 <vfprintf+0x2f6>
 a9e:	fe 01       	movw	r30, r28
 aa0:	e7 0d       	add	r30, r7
 aa2:	f1 1d       	adc	r31, r1
 aa4:	20 81       	ld	r18, Z
 aa6:	20 33       	cpi	r18, 0x30	; 48
 aa8:	19 f4       	brne	.+6      	; 0xab0 <vfprintf+0x2ee>
 aaa:	e9 ee       	ldi	r30, 0xE9	; 233
 aac:	be 22       	and	r11, r30
 aae:	09 c0       	rjmp	.+18     	; 0xac2 <vfprintf+0x300>
 ab0:	a3 94       	inc	r10
 ab2:	b2 fe       	sbrs	r11, 2
 ab4:	06 c0       	rjmp	.+12     	; 0xac2 <vfprintf+0x300>
 ab6:	04 c0       	rjmp	.+8      	; 0xac0 <vfprintf+0x2fe>
 ab8:	86 78       	andi	r24, 0x86	; 134
 aba:	90 70       	andi	r25, 0x00	; 0
 abc:	00 97       	sbiw	r24, 0x00	; 0
 abe:	09 f0       	breq	.+2      	; 0xac2 <vfprintf+0x300>
 ac0:	a3 94       	inc	r10
 ac2:	8b 2c       	mov	r8, r11
 ac4:	99 24       	eor	r9, r9
 ac6:	b3 fc       	sbrc	r11, 3
 ac8:	14 c0       	rjmp	.+40     	; 0xaf2 <vfprintf+0x330>
 aca:	b0 fe       	sbrs	r11, 0
 acc:	0f c0       	rjmp	.+30     	; 0xaec <vfprintf+0x32a>
 ace:	af 14       	cp	r10, r15
 ad0:	28 f4       	brcc	.+10     	; 0xadc <vfprintf+0x31a>
 ad2:	e7 2c       	mov	r14, r7
 ad4:	ef 0c       	add	r14, r15
 ad6:	ea 18       	sub	r14, r10
 ad8:	af 2c       	mov	r10, r15
 ada:	08 c0       	rjmp	.+16     	; 0xaec <vfprintf+0x32a>
 adc:	e7 2c       	mov	r14, r7
 ade:	06 c0       	rjmp	.+12     	; 0xaec <vfprintf+0x32a>
 ae0:	80 e2       	ldi	r24, 0x20	; 32
 ae2:	90 e0       	ldi	r25, 0x00	; 0
 ae4:	b6 01       	movw	r22, r12
 ae6:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 aea:	a3 94       	inc	r10
 aec:	af 14       	cp	r10, r15
 aee:	c0 f3       	brcs	.-16     	; 0xae0 <vfprintf+0x31e>
 af0:	04 c0       	rjmp	.+8      	; 0xafa <vfprintf+0x338>
 af2:	af 14       	cp	r10, r15
 af4:	10 f4       	brcc	.+4      	; 0xafa <vfprintf+0x338>
 af6:	fa 18       	sub	r15, r10
 af8:	01 c0       	rjmp	.+2      	; 0xafc <vfprintf+0x33a>
 afa:	ff 24       	eor	r15, r15
 afc:	84 fe       	sbrs	r8, 4
 afe:	0f c0       	rjmp	.+30     	; 0xb1e <vfprintf+0x35c>
 b00:	80 e3       	ldi	r24, 0x30	; 48
 b02:	90 e0       	ldi	r25, 0x00	; 0
 b04:	b6 01       	movw	r22, r12
 b06:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 b0a:	82 fe       	sbrs	r8, 2
 b0c:	1f c0       	rjmp	.+62     	; 0xb4c <vfprintf+0x38a>
 b0e:	81 fe       	sbrs	r8, 1
 b10:	03 c0       	rjmp	.+6      	; 0xb18 <vfprintf+0x356>
 b12:	88 e5       	ldi	r24, 0x58	; 88
 b14:	90 e0       	ldi	r25, 0x00	; 0
 b16:	10 c0       	rjmp	.+32     	; 0xb38 <vfprintf+0x376>
 b18:	88 e7       	ldi	r24, 0x78	; 120
 b1a:	90 e0       	ldi	r25, 0x00	; 0
 b1c:	0d c0       	rjmp	.+26     	; 0xb38 <vfprintf+0x376>
 b1e:	c4 01       	movw	r24, r8
 b20:	86 78       	andi	r24, 0x86	; 134
 b22:	90 70       	andi	r25, 0x00	; 0
 b24:	00 97       	sbiw	r24, 0x00	; 0
 b26:	91 f0       	breq	.+36     	; 0xb4c <vfprintf+0x38a>
 b28:	81 fc       	sbrc	r8, 1
 b2a:	02 c0       	rjmp	.+4      	; 0xb30 <vfprintf+0x36e>
 b2c:	80 e2       	ldi	r24, 0x20	; 32
 b2e:	01 c0       	rjmp	.+2      	; 0xb32 <vfprintf+0x370>
 b30:	8b e2       	ldi	r24, 0x2B	; 43
 b32:	b7 fc       	sbrc	r11, 7
 b34:	8d e2       	ldi	r24, 0x2D	; 45
 b36:	90 e0       	ldi	r25, 0x00	; 0
 b38:	b6 01       	movw	r22, r12
 b3a:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 b3e:	06 c0       	rjmp	.+12     	; 0xb4c <vfprintf+0x38a>
 b40:	80 e3       	ldi	r24, 0x30	; 48
 b42:	90 e0       	ldi	r25, 0x00	; 0
 b44:	b6 01       	movw	r22, r12
 b46:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 b4a:	ea 94       	dec	r14
 b4c:	7e 14       	cp	r7, r14
 b4e:	c0 f3       	brcs	.-16     	; 0xb40 <vfprintf+0x37e>
 b50:	7a 94       	dec	r7
 b52:	f2 01       	movw	r30, r4
 b54:	e7 0d       	add	r30, r7
 b56:	f1 1d       	adc	r31, r1
 b58:	80 81       	ld	r24, Z
 b5a:	90 e0       	ldi	r25, 0x00	; 0
 b5c:	b6 01       	movw	r22, r12
 b5e:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 b62:	77 20       	and	r7, r7
 b64:	a9 f7       	brne	.-22     	; 0xb50 <vfprintf+0x38e>
 b66:	06 c0       	rjmp	.+12     	; 0xb74 <vfprintf+0x3b2>
 b68:	80 e2       	ldi	r24, 0x20	; 32
 b6a:	90 e0       	ldi	r25, 0x00	; 0
 b6c:	b6 01       	movw	r22, r12
 b6e:	0e 94 de 05 	call	0xbbc	; 0xbbc <fputc>
 b72:	fa 94       	dec	r15
 b74:	ff 20       	and	r15, r15
 b76:	c1 f7       	brne	.-16     	; 0xb68 <vfprintf+0x3a6>
 b78:	37 ce       	rjmp	.-914    	; 0x7e8 <vfprintf+0x26>
 b7a:	f6 01       	movw	r30, r12
 b7c:	26 81       	ldd	r18, Z+6	; 0x06
 b7e:	37 81       	ldd	r19, Z+7	; 0x07
 b80:	02 c0       	rjmp	.+4      	; 0xb86 <vfprintf+0x3c4>
 b82:	2f ef       	ldi	r18, 0xFF	; 255
 b84:	3f ef       	ldi	r19, 0xFF	; 255
 b86:	c9 01       	movw	r24, r18
 b88:	2c 96       	adiw	r28, 0x0c	; 12
 b8a:	e2 e1       	ldi	r30, 0x12	; 18
 b8c:	0c 94 84 06 	jmp	0xd08	; 0xd08 <__epilogue_restores__>

00000b90 <strnlen_P>:
 b90:	fc 01       	movw	r30, r24
 b92:	05 90       	lpm	r0, Z+
 b94:	61 50       	subi	r22, 0x01	; 1
 b96:	70 40       	sbci	r23, 0x00	; 0
 b98:	01 10       	cpse	r0, r1
 b9a:	d8 f7       	brcc	.-10     	; 0xb92 <strnlen_P+0x2>
 b9c:	80 95       	com	r24
 b9e:	90 95       	com	r25
 ba0:	8e 0f       	add	r24, r30
 ba2:	9f 1f       	adc	r25, r31
 ba4:	08 95       	ret

00000ba6 <strnlen>:
 ba6:	fc 01       	movw	r30, r24
 ba8:	61 50       	subi	r22, 0x01	; 1
 baa:	70 40       	sbci	r23, 0x00	; 0
 bac:	01 90       	ld	r0, Z+
 bae:	01 10       	cpse	r0, r1
 bb0:	d8 f7       	brcc	.-10     	; 0xba8 <strnlen+0x2>
 bb2:	80 95       	com	r24
 bb4:	90 95       	com	r25
 bb6:	8e 0f       	add	r24, r30
 bb8:	9f 1f       	adc	r25, r31
 bba:	08 95       	ret

00000bbc <fputc>:
 bbc:	0f 93       	push	r16
 bbe:	1f 93       	push	r17
 bc0:	cf 93       	push	r28
 bc2:	df 93       	push	r29
 bc4:	8c 01       	movw	r16, r24
 bc6:	eb 01       	movw	r28, r22
 bc8:	8b 81       	ldd	r24, Y+3	; 0x03
 bca:	81 ff       	sbrs	r24, 1
 bcc:	1b c0       	rjmp	.+54     	; 0xc04 <fputc+0x48>
 bce:	82 ff       	sbrs	r24, 2
 bd0:	0d c0       	rjmp	.+26     	; 0xbec <fputc+0x30>
 bd2:	2e 81       	ldd	r18, Y+6	; 0x06
 bd4:	3f 81       	ldd	r19, Y+7	; 0x07
 bd6:	8c 81       	ldd	r24, Y+4	; 0x04
 bd8:	9d 81       	ldd	r25, Y+5	; 0x05
 bda:	28 17       	cp	r18, r24
 bdc:	39 07       	cpc	r19, r25
 bde:	64 f4       	brge	.+24     	; 0xbf8 <fputc+0x3c>
 be0:	e8 81       	ld	r30, Y
 be2:	f9 81       	ldd	r31, Y+1	; 0x01
 be4:	01 93       	st	Z+, r16
 be6:	f9 83       	std	Y+1, r31	; 0x01
 be8:	e8 83       	st	Y, r30
 bea:	06 c0       	rjmp	.+12     	; 0xbf8 <fputc+0x3c>
 bec:	e8 85       	ldd	r30, Y+8	; 0x08
 bee:	f9 85       	ldd	r31, Y+9	; 0x09
 bf0:	80 2f       	mov	r24, r16
 bf2:	09 95       	icall
 bf4:	00 97       	sbiw	r24, 0x00	; 0
 bf6:	31 f4       	brne	.+12     	; 0xc04 <fputc+0x48>
 bf8:	8e 81       	ldd	r24, Y+6	; 0x06
 bfa:	9f 81       	ldd	r25, Y+7	; 0x07
 bfc:	01 96       	adiw	r24, 0x01	; 1
 bfe:	9f 83       	std	Y+7, r25	; 0x07
 c00:	8e 83       	std	Y+6, r24	; 0x06
 c02:	02 c0       	rjmp	.+4      	; 0xc08 <fputc+0x4c>
 c04:	0f ef       	ldi	r16, 0xFF	; 255
 c06:	1f ef       	ldi	r17, 0xFF	; 255
 c08:	c8 01       	movw	r24, r16
 c0a:	df 91       	pop	r29
 c0c:	cf 91       	pop	r28
 c0e:	1f 91       	pop	r17
 c10:	0f 91       	pop	r16
 c12:	08 95       	ret

00000c14 <__ultoa_invert>:
 c14:	fa 01       	movw	r30, r20
 c16:	aa 27       	eor	r26, r26
 c18:	28 30       	cpi	r18, 0x08	; 8
 c1a:	51 f1       	breq	.+84     	; 0xc70 <__ultoa_invert+0x5c>
 c1c:	20 31       	cpi	r18, 0x10	; 16
 c1e:	81 f1       	breq	.+96     	; 0xc80 <__ultoa_invert+0x6c>
 c20:	e8 94       	clt
 c22:	6f 93       	push	r22
 c24:	6e 7f       	andi	r22, 0xFE	; 254
 c26:	6e 5f       	subi	r22, 0xFE	; 254
 c28:	7f 4f       	sbci	r23, 0xFF	; 255
 c2a:	8f 4f       	sbci	r24, 0xFF	; 255
 c2c:	9f 4f       	sbci	r25, 0xFF	; 255
 c2e:	af 4f       	sbci	r26, 0xFF	; 255
 c30:	b1 e0       	ldi	r27, 0x01	; 1
 c32:	3e d0       	rcall	.+124    	; 0xcb0 <__ultoa_invert+0x9c>
 c34:	b4 e0       	ldi	r27, 0x04	; 4
 c36:	3c d0       	rcall	.+120    	; 0xcb0 <__ultoa_invert+0x9c>
 c38:	67 0f       	add	r22, r23
 c3a:	78 1f       	adc	r23, r24
 c3c:	89 1f       	adc	r24, r25
 c3e:	9a 1f       	adc	r25, r26
 c40:	a1 1d       	adc	r26, r1
 c42:	68 0f       	add	r22, r24
 c44:	79 1f       	adc	r23, r25
 c46:	8a 1f       	adc	r24, r26
 c48:	91 1d       	adc	r25, r1
 c4a:	a1 1d       	adc	r26, r1
 c4c:	6a 0f       	add	r22, r26
 c4e:	71 1d       	adc	r23, r1
 c50:	81 1d       	adc	r24, r1
 c52:	91 1d       	adc	r25, r1
 c54:	a1 1d       	adc	r26, r1
 c56:	20 d0       	rcall	.+64     	; 0xc98 <__ultoa_invert+0x84>
 c58:	09 f4       	brne	.+2      	; 0xc5c <__ultoa_invert+0x48>
 c5a:	68 94       	set
 c5c:	3f 91       	pop	r19
 c5e:	2a e0       	ldi	r18, 0x0A	; 10
 c60:	26 9f       	mul	r18, r22
 c62:	11 24       	eor	r1, r1
 c64:	30 19       	sub	r19, r0
 c66:	30 5d       	subi	r19, 0xD0	; 208
 c68:	31 93       	st	Z+, r19
 c6a:	de f6       	brtc	.-74     	; 0xc22 <__ultoa_invert+0xe>
 c6c:	cf 01       	movw	r24, r30
 c6e:	08 95       	ret
 c70:	46 2f       	mov	r20, r22
 c72:	47 70       	andi	r20, 0x07	; 7
 c74:	40 5d       	subi	r20, 0xD0	; 208
 c76:	41 93       	st	Z+, r20
 c78:	b3 e0       	ldi	r27, 0x03	; 3
 c7a:	0f d0       	rcall	.+30     	; 0xc9a <__ultoa_invert+0x86>
 c7c:	c9 f7       	brne	.-14     	; 0xc70 <__ultoa_invert+0x5c>
 c7e:	f6 cf       	rjmp	.-20     	; 0xc6c <__ultoa_invert+0x58>
 c80:	46 2f       	mov	r20, r22
 c82:	4f 70       	andi	r20, 0x0F	; 15
 c84:	40 5d       	subi	r20, 0xD0	; 208
 c86:	4a 33       	cpi	r20, 0x3A	; 58
 c88:	18 f0       	brcs	.+6      	; 0xc90 <__ultoa_invert+0x7c>
 c8a:	49 5d       	subi	r20, 0xD9	; 217
 c8c:	31 fd       	sbrc	r19, 1
 c8e:	40 52       	subi	r20, 0x20	; 32
 c90:	41 93       	st	Z+, r20
 c92:	02 d0       	rcall	.+4      	; 0xc98 <__ultoa_invert+0x84>
 c94:	a9 f7       	brne	.-22     	; 0xc80 <__ultoa_invert+0x6c>
 c96:	ea cf       	rjmp	.-44     	; 0xc6c <__ultoa_invert+0x58>
 c98:	b4 e0       	ldi	r27, 0x04	; 4
 c9a:	a6 95       	lsr	r26
 c9c:	97 95       	ror	r25
 c9e:	87 95       	ror	r24
 ca0:	77 95       	ror	r23
 ca2:	67 95       	ror	r22
 ca4:	ba 95       	dec	r27
 ca6:	c9 f7       	brne	.-14     	; 0xc9a <__ultoa_invert+0x86>
 ca8:	00 97       	sbiw	r24, 0x00	; 0
 caa:	61 05       	cpc	r22, r1
 cac:	71 05       	cpc	r23, r1
 cae:	08 95       	ret
 cb0:	9b 01       	movw	r18, r22
 cb2:	ac 01       	movw	r20, r24
 cb4:	0a 2e       	mov	r0, r26
 cb6:	06 94       	lsr	r0
 cb8:	57 95       	ror	r21
 cba:	47 95       	ror	r20
 cbc:	37 95       	ror	r19
 cbe:	27 95       	ror	r18
 cc0:	ba 95       	dec	r27
 cc2:	c9 f7       	brne	.-14     	; 0xcb6 <__ultoa_invert+0xa2>
 cc4:	62 0f       	add	r22, r18
 cc6:	73 1f       	adc	r23, r19
 cc8:	84 1f       	adc	r24, r20
 cca:	95 1f       	adc	r25, r21
 ccc:	a0 1d       	adc	r26, r0
 cce:	08 95       	ret

00000cd0 <__prologue_saves__>:
 cd0:	2f 92       	push	r2
 cd2:	3f 92       	push	r3
 cd4:	4f 92       	push	r4
 cd6:	5f 92       	push	r5
 cd8:	6f 92       	push	r6
 cda:	7f 92       	push	r7
 cdc:	8f 92       	push	r8
 cde:	9f 92       	push	r9
 ce0:	af 92       	push	r10
 ce2:	bf 92       	push	r11
 ce4:	cf 92       	push	r12
 ce6:	df 92       	push	r13
 ce8:	ef 92       	push	r14
 cea:	ff 92       	push	r15
 cec:	0f 93       	push	r16
 cee:	1f 93       	push	r17
 cf0:	cf 93       	push	r28
 cf2:	df 93       	push	r29
 cf4:	cd b7       	in	r28, 0x3d	; 61
 cf6:	de b7       	in	r29, 0x3e	; 62
 cf8:	ca 1b       	sub	r28, r26
 cfa:	db 0b       	sbc	r29, r27
 cfc:	0f b6       	in	r0, 0x3f	; 63
 cfe:	f8 94       	cli
 d00:	de bf       	out	0x3e, r29	; 62
 d02:	0f be       	out	0x3f, r0	; 63
 d04:	cd bf       	out	0x3d, r28	; 61
 d06:	09 94       	ijmp

00000d08 <__epilogue_restores__>:
 d08:	2a 88       	ldd	r2, Y+18	; 0x12
 d0a:	39 88       	ldd	r3, Y+17	; 0x11
 d0c:	48 88       	ldd	r4, Y+16	; 0x10
 d0e:	5f 84       	ldd	r5, Y+15	; 0x0f
 d10:	6e 84       	ldd	r6, Y+14	; 0x0e
 d12:	7d 84       	ldd	r7, Y+13	; 0x0d
 d14:	8c 84       	ldd	r8, Y+12	; 0x0c
 d16:	9b 84       	ldd	r9, Y+11	; 0x0b
 d18:	aa 84       	ldd	r10, Y+10	; 0x0a
 d1a:	b9 84       	ldd	r11, Y+9	; 0x09
 d1c:	c8 84       	ldd	r12, Y+8	; 0x08
 d1e:	df 80       	ldd	r13, Y+7	; 0x07
 d20:	ee 80       	ldd	r14, Y+6	; 0x06
 d22:	fd 80       	ldd	r15, Y+5	; 0x05
 d24:	0c 81       	ldd	r16, Y+4	; 0x04
 d26:	1b 81       	ldd	r17, Y+3	; 0x03
 d28:	aa 81       	ldd	r26, Y+2	; 0x02
 d2a:	b9 81       	ldd	r27, Y+1	; 0x01
 d2c:	ce 0f       	add	r28, r30
 d2e:	d1 1d       	adc	r29, r1
 d30:	0f b6       	in	r0, 0x3f	; 63
 d32:	f8 94       	cli
 d34:	de bf       	out	0x3e, r29	; 62
 d36:	0f be       	out	0x3f, r0	; 63
 d38:	cd bf       	out	0x3d, r28	; 61
 d3a:	ed 01       	movw	r28, r26
 d3c:	08 95       	ret

00000d3e <_exit>:
 d3e:	f8 94       	cli

00000d40 <__stop_program>:
 d40:	ff cf       	rjmp	.-2      	; 0xd40 <__stop_program>
